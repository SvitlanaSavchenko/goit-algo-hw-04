Python має дві вбудовані функції сортування: `sorted` і `sort`. Функції сортування Python використовують Timsort — гібридний алгоритм сортування, що поєднує в собі сортування злиттям і сортування вставками.

Порівняйте три алгоритми сортування: злиттям, вставками та Timsort за часом виконання. Аналіз повинен бути підтверджений емпіричними даними, отриманими шляхом тестування алгоритмів на різних наборах даних. Емпірично перевірте теоретичні оцінки складності алгоритмів, наприклад, сортуванням на великих масивах. Для заміру часу виконання алгоритмів використовуйте модуль timeit.

Покажіть, що поєднання сортування злиттям і сортування вставками робить алгоритм Timsort набагато ефективнішим, і саме з цієї причини програмісти, в більшості випадків, використовують вбудовані в Python алгоритми, а не кодують самі. Зробіть висновки.

**Необов'язкове завдання**

Дано `k` відсортованих списків цілих чисел. Ваше завдання — об'єднати їх у один відсортований список. При виконанні завдання можете опиратися на алгоритм сортування злиттям з конспекту. Реалізуйте функцію `merge_k_lists`, яка приймає на вхід список відсортованих списків та повертає відсортований список.

Приклад очікуваного результату:

```Python
lists = [[1, 4, 5], [1, 3, 4], [2, 6]]
merged_list = merge_k_lists(lists)
print("Відсортований список:", merged_list)
```

Виведення:

```Python
Відсортований список: [1, 1, 2, 3, 4, 4, 5, 6]
```

### Критерії прийняття ДЗ

Прикріплені посилання на репозиторій `goit-algo-hw-04` та безпосередньо сам файл репозиторію у форматі `zip`.
Виконано порівняльний аналіз алгоритмів за часом виконання шляхом їх тестування на різних наборах даних.
Емпірично перевірено теоретичні оцінки складності алгоритмів та доведено, що поєднання сортування злиттям і сортування вставками робить алгоритм Timsort набагато ефективнішим.
Зроблено висновки щодо ефективності алгоритмів для даного випадку. Висновки оформлено у вигляді файлу readme.md до домашнього завдання.

# Аналіз алгоритмів сортування

## Результати тестування

+--------+-------------+------------------+----------------------+---------------+
| Size | Data Type | Merge Sort (s) | Insertion Sort (s) | Timsort (s) |
+========+=============+==================+======================+===============+
| 100 | random | 0.000114 | 0.000145 | 0.000006 |
+--------+-------------+------------------+----------------------+---------------+
| 100 | sorted | 0.000096 | 0.000007 | 0.000001 |
+--------+-------------+------------------+----------------------+---------------+
| 100 | reversed | 0.000099 | 0.000409 | 0.000001 |
+--------+-------------+------------------+----------------------+---------------+
| 1000 | random | 0.001573 | 0.019219 | 0.000084 |
+--------+-------------+------------------+----------------------+---------------+
| 1000 | sorted | 0.001722 | 0.000094 | 0.000006 |
+--------+-------------+------------------+----------------------+---------------+
| 1000 | reversed | 0.001496 | 0.038698 | 0.000009 |
+--------+-------------+------------------+----------------------+---------------+
| 10000 | random | 0.023777 | 2.743598 | 0.001651 |
+--------+-------------+------------------+----------------------+---------------+
| 10000 | sorted | 0.031817 | 0.001524 | 0.000087 |
+--------+-------------+------------------+----------------------+---------------+
| 10000 | reversed | 0.028436 | 5.034191 | 0.000085 |
+--------+-------------+------------------+----------------------+---------------+

## Висновки

- **Timsort** є найшвидшим алгоритмом серед трьох тестованих, завдяки поєднанню ефективності злиття і вставок.
- **Сортування злиттям** є стабільним та ефективним для великих наборів даних, але не може перевершити Timsort.
- **Сортування вставками** підходить для невеликих та частково відсортованих масивів, але значно поступається на великих невідсортованих масивах.

Ці висновки підтверджують, чому Python використовує Timsort для своєї вбудованої функції `sorted`.
